"""
Django settings for yepsoftware_incidence_detection project.

Generated by 'django-admin startproject' using Django 5.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""
import os
from pathlib import Path
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.getenv('DEBUG')

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth', #is the core of Django's built-in authentication and authorization system. It provides the framework and default implementations for managing users, groups, permissions, and handling user login and logout.
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.humanize',
    'import_export',
    'accounts',
    'products',
    'incidences',
    'fontawesomefree',
    'django_q', #Django Q2 is a native Django task queue, scheduler and worker application using Python multiprocessing. Doc: https://django-q2.readthedocs.io/en/master/index.html
]

#A Distributed Task Queue is a system used in distributed computing to manage and coordinate tasks across multiple machines or servers. Instead of one machine handling all tasks, a distributed task queue spreads out the work, making the process faster and more efficient. Each task is placed in a queue, and available workers pick up and complete tasks as they come in. This approach helps balance the workload, improves system reliability, and ensures that tasks are completed even if some machines fail. It's commonly used in large-scale applications and cloud services.


# Configure your Q cluster
# Django Q2 uses Python’s multiprocessing module to manage a pool of workers that will handle your tasks. tart your cluster using Django’s manage.py command: python manage.py qcluster
Q_CLUSTER = {
    'name': 'AsyncBroker', #Used to differentiate between projects using the same broker. On most broker types this will be used as the queue name. Defaults to 'default'.
    'workers': 8, #The number of workers to use in the cluster. Defaults to CPU count of the current host, but can be set to a custom number.
    'timeout': 1000, #The number of seconds a worker is allowed to spend on a task before it’s terminated. Defaults to None, meaning it will never time out. Set this to something that makes sense for your project. Can be overridden for individual tasks.
    'retry': 1200, #The number of seconds a broker will wait for a cluster to finish a task, before it’s presented again. Only works with brokers that support delivery receipts. Defaults to 60.
    #The value must be bigger than the time it takes to complete longest task, i.e. timeout must be less than retry value and all tasks must complete in less time than the selected retry time. If this does not hold, i.e. the retry value is less than timeout or less than it takes to finish a task, Django-Q2 will start the task again if the used broker supports receipts.
    'queue_limit': 50, #This does not limit the amount of tasks that can be queued on the broker, but rather how many tasks are kept in memory by a single cluster. Setting this to a reasonable number, can help balance the workload and the memory overhead of each individual cluster. Defaults to workers**2.
    'orm': 'default' # Use Django's ORM + database for broker. The broker sits between your Django instances and your Django Q2 cluster instances; accepting, saving and delivering task packages. Currently we support a variety of brokers. Is more or less like a post office box: it takes messages, holds them in a queue, and folks from around the city can retrieve these messages later.
}

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'yepsoftware_incidence_detection.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')], #Register all your apps, and Django will look for any files inside a folder named templates as you mentioned in os.path.join(BASE_DIR, 'templates').
        #BASE_DIR: Represents your root project, so you don't need to hard code the absolute path
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'yepsoftware_incidence_detection.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'es'

TIME_ZONE = 'America/Santiago'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/' #URL to use when referring to static files located in STATIC_ROOT. Sets the absolute location of these collected files, typically called staticfiles. In other words, when collecstatic is run locally, it will combine all available static files, as defined by STATICFILES_DIRS, and place them within a directory called staticfiles.

STATICFILES_DIRS = [ #is the list of folders where Django will search for additional static files aside from the static folder of each app installed.
    BASE_DIR / "static",
]

STATIC_ROOT = BASE_DIR / "staticfiles" #Is the folder where static files will be stored after using manage.py collectstatic. Solo se usa en producción

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


#---- Falabella API data -----
FAL_URL = os.getenv('FAL_URL')
FAL_API_KEY = os.getenv('FAL_API_KEY')
FAL_USER_ID = os.getenv('FAL_USER_ID')
FAL_USER_AGENT = os.getenv('FAL_USER_AGENT')

#---- Walmart API data -----
WALMART_CLIENT_ID = os.getenv('WALMART_CLIENT_ID')
WALMART_CLIENT_SECRET = os.getenv('WALMART_CLIENT_SECRET')

#---- Paris API data -----
PARIS_API_KEY = os.getenv('PARIS_API_KEY')